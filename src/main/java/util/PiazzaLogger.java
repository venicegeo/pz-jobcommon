/**
 * Copyright 2016, RadiantBlue Technologies, Inc.
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *   http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 **/
package util;

import java.net.InetAddress;
import java.time.Instant;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.PostConstruct;

import org.apache.http.client.HttpClient;
import org.apache.http.impl.client.HttpClientBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.client.HttpComponentsClientHttpRequestFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import model.request.LogRequest;

/**
 * PiazzaLogger is a class that logs using the Piazza Core Logger service.
 * 
 * @author mlynum, rorf, patrick.doody
 * @version 1.0
 */
@Component
public class PiazzaLogger {
	@Value("${logger.url}")
	private String LOGGER_URL;
	@Value("${logger.endpoint}")
	private String LOGGER_ENDPOINT;
	@Value("${logger.name:}")
	private String serviceName;
	@Value("${logger.console:}")
	private Boolean logToConsole;
	@Value("${http.max.total:5000}")
	private int httpMaxTotal;
	@Value("${http.max.route:2500}")
	private int httpMaxRoute;

	public static final String DEBUG = "Debug";
	public static final String ERROR = "Error";
	public static final String FATAL = "Fatal";
	public static final String INFO = "Info";
	public static final String WARNING = "Warning";
	private static final String[] SEVERITY_OPTIONS = { DEBUG, ERROR, FATAL, INFO, WARNING };

	private RestTemplate restTemplate = new RestTemplate();
	private final static Logger LOGGER = LoggerFactory.getLogger(PiazzaLogger.class);

	/**
	 * Default constructor, required for beat instantiation.
	 */
	public PiazzaLogger() {
	}

	/**
	 * Creates a new Logger component. This constructor is not recommended. It's more recommended to have your project
	 * populate the pz.logger.url and pz.logger.name properties, and allow Spring to Autowire this object. However, this
	 * constructor exists for cases where that is not an option..
	 * 
	 * @param loggerServiceUrl
	 *            The URL of the PiazzaLogger service.
	 * @param serviceName
	 *            The name of the pz-component that utilizes this logger. The name of the component will be included in
	 *            the message content for every log message generated by this instance of the PiazzaLogger.
	 */
	public PiazzaLogger(String loggerServiceUrl, String serviceName) {
		this.serviceName = serviceName;
		this.LOGGER_URL = loggerServiceUrl;
	}

	@PostConstruct
	public void init() {
		LOGGER.info(String.format("PiazzaLogger initialized for service %s, url: %s", serviceName, LOGGER_URL));
		HttpClient httpClient = HttpClientBuilder.create().setMaxConnTotal(httpMaxTotal).setMaxConnPerRoute(httpMaxRoute).build();
		restTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient));
	}

	/**
	 * Sends a Log message to the Pz-Logger service.
	 * 
	 * @param logMessage
	 *            the message you want to log
	 * @param severity
	 *            the severity of the log
	 */
	public void log(String logMessage, String severity) {
		if (isLogInputValid(logMessage, severity)) {
			// Log the message with the Piazza Logger service
			try {
				HttpHeaders headers = new HttpHeaders();
				headers.setContentType(MediaType.APPLICATION_JSON);

				LogRequest logRequest = new LogRequest(serviceName, InetAddress.getLocalHost().toString(), Instant.now().toString(),
						logMessage, severity);

				// Log the message locally if requested
				try {
					if (logToConsole.booleanValue()) {
						LOGGER.info(logRequest.toPrettyString());
					}
				} catch (Exception exception) { /* Do nothing. */
					LOGGER.error("Application property is not set", exception);
				}

				String url = String.format("%s/%s", LOGGER_URL, LOGGER_ENDPOINT);
				restTemplate.postForEntity(url, new HttpEntity<LogRequest>(logRequest, headers), String.class);
			} catch (Exception exception) {
				LOGGER.error("PiazzaLogger could not log: ", exception);
			}
		}
	}

	/**
	 * 
	 * @param count
	 * @return
	 */
	public List<LogRequest> getLogs(Integer count) {
		try {
			Map<String, Integer> map = new HashMap<String, Integer>();
			map.put("count", count);
			String url = String.format("%s/%s", LOGGER_URL, LOGGER_ENDPOINT);
			ResponseEntity<LogRequest[]> logs = restTemplate.getForEntity(url + "?count={count}", LogRequest[].class, map);
			return (List<LogRequest>) Arrays.asList(logs.getBody());
		} catch (Exception exception) {
			LOGGER.error("Error occurred while obtaining logs", exception);
			return null;
		}
	}

	/**
	 * Provides simple validation for log messages.
	 */
	private boolean isLogInputValid(String logMessage, String severity) {
		if (logMessage == null || logMessage.length() == 0) {
			LOGGER.error("Message is null. Logger cannot send an empty message. This is a required field.");
			return false;
		}
		if (severity == null || severity.length() == 0) {
			LOGGER.error("Severity is null. Logger cannot send message without a severity. This is a required field.");
			return false;
		}
		if (!Arrays.asList(SEVERITY_OPTIONS).contains(severity)) {
			LOGGER.error("Severity '" + severity + "' is not one of the available options: " + Arrays.toString(SEVERITY_OPTIONS));
			return false;
		}

		return true;
	}
}